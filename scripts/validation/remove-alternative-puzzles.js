#!/usr/bin/env node

/**
 * Script to remove puzzles that have alternative solutions from puzzle-data.js
 * Reads the alternative-solutions.json file generated by check-alternative-solutions.js
 * and removes all puzzles that have alternative solutions.
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const PUZZLE_DATA_PATH = path.join(__dirname, '../../puzzle-data.js');
const ALTERNATIVE_SOLUTIONS_PATH = path.join(__dirname, 'alternative-solutions.json');

/**
 * Load alternative solutions data
 */
function loadAlternativeSolutions() {
    if (!fs.existsSync(ALTERNATIVE_SOLUTIONS_PATH)) {
        throw new Error(
            `Alternative solutions file not found: ${ALTERNATIVE_SOLUTIONS_PATH}\n` +
            `Please run: npm run validate:alternatives first`
        );
    }
    
    const data = fs.readFileSync(ALTERNATIVE_SOLUTIONS_PATH, 'utf8');
    return JSON.parse(data);
}

/**
 * Extract and parse PUZZLE_DATA from source file
 */
function loadPuzzleData() {
    const sourceCode = fs.readFileSync(PUZZLE_DATA_PATH, 'utf8');
    
    // Extract PUZZLE_DATA using regex (similar to encode-puzzle-data.js)
    const puzzleDataMatch = sourceCode.match(/export const PUZZLE_DATA = \{[\s\S]*?\};/);
    
    if (!puzzleDataMatch) {
        throw new Error('Could not extract PUZZLE_DATA from source file');
    }
    
    // Extract the object content
    const puzzleDataStr = puzzleDataMatch[0].replace(/export const PUZZLE_DATA = /, '').replace(/;$/, '');
    
    // Parse to get the actual object (safe since it's from our own source file)
    let PUZZLE_DATA;
    try {
        PUZZLE_DATA = eval(`(${puzzleDataStr})`);
    } catch (e) {
        throw new Error(`Error parsing puzzle data: ${e.message}`);
    }
    
    return { PUZZLE_DATA, sourceCode };
}

/**
 * Write updated puzzle data back to file
 * Regenerates the PUZZLE_DATA object with puzzles removed
 */
function writePuzzleData(sourceCode, updatedData, removedPuzzles) {
    // Create a backup
    const backupPath = PUZZLE_DATA_PATH + '.backup';
    fs.writeFileSync(backupPath, sourceCode);
    console.log(`✓ Backup created: ${backupPath}`);
    
    // Find the start and end of PUZZLE_DATA object
    const dataStartMatch = sourceCode.match(/export const PUZZLE_DATA = \{/);
    if (!dataStartMatch) {
        throw new Error('Could not find PUZZLE_DATA declaration in puzzle-data.js');
    }
    
    const dataStart = dataStartMatch.index + dataStartMatch[0].length;
    
    // Find the closing brace of PUZZLE_DATA object
    let braceCount = 1;
    let dataEnd = dataStart;
    for (let i = dataStart; i < sourceCode.length && braceCount > 0; i++) {
        if (sourceCode[i] === '{') braceCount++;
        if (sourceCode[i] === '}') braceCount--;
        if (braceCount === 0) {
            dataEnd = i;
            break;
        }
    }
    
    // Build new puzzle data content
    const puzzleNumbers = Object.keys(updatedData)
        .map(Number)
        .sort((a, b) => a - b);
    
    let newDataContent = '';
    for (const puzzleNum of puzzleNumbers) {
        const puzzle = updatedData[puzzleNum];
        newDataContent += `    ${puzzleNum}: {\n`;
        newDataContent += `        words: [${puzzle.words.map(w => `'${w}'`).join(', ')}],\n`;
        newDataContent += `        solution: [${puzzle.solution.map(w => `'${w}'`).join(', ')}]\n`;
        newDataContent += `    },\n`;
    }
    
    // Reconstruct the file
    const beforeData = sourceCode.substring(0, dataStart);
    const afterData = sourceCode.substring(dataEnd);
    
    const newContent = beforeData + '\n' + newDataContent + afterData;
    
    // Write the updated content
    fs.writeFileSync(PUZZLE_DATA_PATH, newContent);
    console.log(`✓ Updated puzzle data written to: ${PUZZLE_DATA_PATH}`);
    console.log(`  Removed ${removedPuzzles.length} puzzle(s)`);
}

/**
 * Main execution function
 */
function main() {
    try {
        console.log('Removing puzzles with alternative solutions from puzzle-data.js...\n');
        
        // Load alternative solutions
        console.log('Loading alternative solutions data...');
        const altSolutions = loadAlternativeSolutions();
        console.log(`Found ${altSolutions.puzzlesWithAlternatives} puzzles with alternative solutions.\n`);
        
        // Load puzzle data
        console.log('Loading puzzle data...');
        const { PUZZLE_DATA, sourceCode } = loadPuzzleData();
        
        // Get puzzle numbers to remove
        const puzzlesToRemove = new Set(altSolutions.results.map(r => r.puzzleNum));
        console.log(`Puzzles to remove: ${Array.from(puzzlesToRemove).sort((a, b) => a - b).join(', ')}\n`);
        
        // Create updated data without removed puzzles
        console.log('Creating updated puzzle data...');
        const updatedData = {};
        let removedCount = 0;
        
        for (const [puzzleNumStr, puzzle] of Object.entries(PUZZLE_DATA)) {
            const puzzleNum = parseInt(puzzleNumStr, 10);
            if (!puzzlesToRemove.has(puzzleNum)) {
                updatedData[puzzleNum] = puzzle;
            } else {
                removedCount++;
            }
        }
        
        console.log(`  Kept ${Object.keys(updatedData).length} puzzle(s)`);
        console.log(`  Removed ${removedCount} puzzle(s)\n`);
        
        // Show summary
        console.log('Puzzles that will be removed:');
        const sortedToRemove = Array.from(puzzlesToRemove).sort((a, b) => a - b);
        for (const puzzleNum of sortedToRemove.slice(0, 10)) {
            const puzzle = PUZZLE_DATA[puzzleNum];
            console.log(`  Puzzle ${puzzleNum}: [${puzzle.solution.join(', ')}]`);
        }
        if (sortedToRemove.length > 10) {
            console.log(`  ... and ${sortedToRemove.length - 10} more`);
        }
        console.log('');
        
        // Write updated data
        console.log('Writing updated puzzle data...');
        writePuzzleData(sourceCode, updatedData, sortedToRemove);
        
        console.log('\n' + '='.repeat(80));
        console.log('✓ Puzzles with alternative solutions removed successfully!');
        console.log('\nNext steps:');
        console.log('1. Review the changes in puzzle-data.js');
        console.log('2. Run: npm run build:data (to rebuild encoded puzzle data)');
        console.log('3. Run: npm run validate:alternatives (to verify no puzzles with alternatives remain)');
        console.log('4. Test the puzzles to ensure they still work correctly');
        console.log('='.repeat(80));
        
    } catch (error) {
        console.error('Error:', error.message);
        process.exit(1);
    }
}

// Run the script
main();
