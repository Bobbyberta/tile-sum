#!/usr/bin/env node

/**
 * Build script to encode puzzle-data.js for obfuscation
 * Reads puzzle-data.js, encodes PUZZLE_DATA using multiple layers,
 * and generates puzzle-data-encoded.js with lazy-loading decoder
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const rootDir = path.resolve(__dirname, '..');

// Simple XOR cipher function
function xorCipher(data, key) {
    const keyStr = String(key);
    return data.split('').map((char, i) => {
        const keyChar = keyStr.charCodeAt(i % keyStr.length);
        return String.fromCharCode(char.charCodeAt(0) ^ keyChar);
    }).join('');
}

// Encode a string with multiple layers
function encodeData(data, seed) {
    // Layer 1: XOR cipher with seed-based key
    const key = `pz${seed}lk${seed * 7}xy`;
    let encoded = xorCipher(data, key);
    
    // Layer 2: Base64 encode
    encoded = Buffer.from(encoded, 'utf8').toString('base64');
    
    return encoded;
}

// Base64 encode (Node.js compatible)
function base64Encode(str) {
    return Buffer.from(str, 'utf8').toString('base64');
}

// Decode function (reverse process) - browser compatible
function generateDecodeFunction() {
    return `
function _d(s, k) {
    const k2 = \`pz\${k}lk\${k * 7}xy\`;
    let d = atob(s);
    const k3 = String(k2);
    return d.split('').map((c, i) => {
        const kc = k3.charCodeAt(i % k3.length);
        return String.fromCharCode(c.charCodeAt(0) ^ kc);
    }).join('');
}`;
}

// Read source file
const sourcePath = path.join(rootDir, 'puzzle-data.js');
const sourceCode = fs.readFileSync(sourcePath, 'utf8');

// Extract PUZZLE_DATA and SCRABBLE_SCORES using regex
// This is a simple approach - in production you might want to use a proper parser
const puzzleDataMatch = sourceCode.match(/export const PUZZLE_DATA = \{[\s\S]*?\};/);
const scrabbleScoresMatch = sourceCode.match(/export const SCRABBLE_SCORES = \{[\s\S]*?\};/);

if (!puzzleDataMatch || !scrabbleScoresMatch) {
    console.error('Could not extract PUZZLE_DATA or SCRABBLE_SCORES from source file');
    process.exit(1);
}

// Extract the object content
const puzzleDataStr = puzzleDataMatch[0].replace(/export const PUZZLE_DATA = /, '').replace(/;$/, '');
const scrabbleScoresStr = scrabbleScoresMatch[0].replace(/export const SCRABBLE_SCORES = /, '').replace(/;$/, '');

// Parse to get the actual objects
let PUZZLE_DATA, SCRABBLE_SCORES;
try {
    // Use eval in a safe way to parse the objects (they're from our own source file)
    PUZZLE_DATA = eval(`(${puzzleDataStr})`);
    SCRABBLE_SCORES = eval(`(${scrabbleScoresStr})`);
} catch (e) {
    console.error('Error parsing puzzle data:', e.message);
    process.exit(1);
}

// Get all puzzle numbers
const puzzleNumbers = Object.keys(PUZZLE_DATA).map(Number).sort((a, b) => a - b);
const maxPuzzle = Math.max(...puzzleNumbers);
const chunkSize = 50; // Puzzles per chunk

// Split puzzles into chunks
const chunks = {};
for (let i = 0; i <= maxPuzzle; i += chunkSize) {
    const chunkStart = i;
    const chunkEnd = Math.min(i + chunkSize - 1, maxPuzzle);
    const chunkKey = `c${Math.floor(i / chunkSize)}`;
    
    // Extract puzzles for this chunk
    const chunkData = {};
    for (let j = chunkStart; j <= chunkEnd; j++) {
        if (PUZZLE_DATA[j]) {
            chunkData[j] = PUZZLE_DATA[j];
        }
    }
    
    // Encode this chunk
    const chunkJson = JSON.stringify(chunkData);
    const seed = Math.floor(i / chunkSize) + 1;
    chunks[chunkKey] = encodeData(chunkJson, seed);
}

// Extract utility functions from source (everything after PUZZLE_DATA)
const utilityStart = sourceCode.indexOf('// Get all letters');
const utilityCode = utilityStart >= 0 ? sourceCode.substring(utilityStart) : '';

// Generate encoded file
const encodedContent = `// Encoded puzzle data - generated by build script
// Do not edit this file directly - edit puzzle-data.js and run: npm run build:data

${generateDecodeFunction()}

// Encoded SCRABBLE_SCORES (small, so encode directly)
const _sc = ${JSON.stringify(encodeData(JSON.stringify(SCRABBLE_SCORES), 999))};
const _scDecoded = JSON.parse(_d(_sc, 999));
export const SCRABBLE_SCORES = _scDecoded;

// Chunk metadata
const _chunks = {
${Object.entries(chunks).map(([key, encoded], idx) => {
    const start = idx * chunkSize;
    const end = Math.min(start + chunkSize - 1, maxPuzzle);
    return `    ${key}: { start: ${start}, end: ${end}, seed: ${idx + 1} }`;
}).join(',\n')}
};

// Decoded chunks cache
const _cache = {};

// Chunk data lookup object
const _chunkData = {
${Object.entries(chunks).map(([key, encoded]) => `    ${key}: ${JSON.stringify(encoded)}`).join(',\n')}
};

// Get chunk for a puzzle number
function _getChunk(puzzleNum) {
    const chunkIdx = Math.floor(puzzleNum / ${chunkSize});
    const chunkKey = \`c\${chunkIdx}\`;
    const chunkInfo = _chunks[chunkKey];
    
    if (!chunkInfo) return null;
    
    // Check cache first
    if (_cache[chunkKey]) {
        return _cache[chunkKey];
    }
    
    // Decode chunk
    const encoded = _chunkData[chunkKey];
    if (!encoded) return null;
    const decoded = JSON.parse(_d(encoded, chunkInfo.seed));
    _cache[chunkKey] = decoded;
    
    return decoded;
}

// Proxy object for PUZZLE_DATA that lazily decodes chunks
const _puzzleDataProxy = new Proxy({}, {
    get(target, prop) {
        const puzzleNum = Number(prop);
        if (isNaN(puzzleNum)) {
            // Handle special properties like 'length', Symbol.iterator, etc.
            return target[prop];
        }
        
        const chunk = _getChunk(puzzleNum);
        return chunk ? chunk[puzzleNum] : undefined;
    },
    has(target, prop) {
        const puzzleNum = Number(prop);
        if (isNaN(puzzleNum)) return prop in target;
        const chunk = _getChunk(puzzleNum);
        return chunk && puzzleNum in chunk;
    },
    ownKeys(target) {
        // Return all puzzle numbers (0 to maxPuzzle)
        return Array.from({ length: ${maxPuzzle + 1} }, (_, i) => String(i));
    },
    getOwnPropertyDescriptor(target, prop) {
        const puzzleNum = Number(prop);
        if (isNaN(puzzleNum)) return undefined;
        const value = _puzzleDataProxy[puzzleNum];
        return value ? { enumerable: true, configurable: true, value } : undefined;
    }
});

export const PUZZLE_DATA = _puzzleDataProxy;

${utilityCode}
`;

// Write encoded file
const outputPath = path.join(rootDir, 'puzzle-data-encoded.js');
fs.writeFileSync(outputPath, encodedContent, 'utf8');

console.log(`âœ“ Encoded puzzle data written to: ${path.relative(rootDir, outputPath)}`);
console.log(`  - ${Object.keys(chunks).length} chunks created`);
console.log(`  - Puzzles 0-${maxPuzzle} encoded`);
console.log(`  - File size: ${(encodedContent.length / 1024).toFixed(2)} KB`);
