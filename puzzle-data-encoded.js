// Encoded puzzle data - generated by build script
// Do not edit this file directly - edit puzzle-data.js and run: npm run build:data


function _d(s, k) {
    const k2 = `pz${k}lk${k * 7}xy`;
    let d = atob(s);
    const k3 = String(k2);
    return d.split('').map((c, i) => {
        const kc = k3.charCodeAt(i % k3.length);
        return String.fromCharCode(c.charCodeAt(0) ^ kc);
    }).join('');
}

// Encoded SCRABBLE_SCORES (small, so encode directly)
const _sc = "C1h4GwNdRxR7GwlLVVI5GwMKQElyGwMBVFs1WAMIFU4tFAMNH1o+UkALFRskSQwNFRExW0pLFRtzTlEOFRt4WkNFVht1G1ZaGht0EUJKXFh3GwNdRxR2GwlJVVIqGwMKQElnGwMCSFVSKBsDCEBJZRsDAlRbJFgDCBVOPhQDCB9aL1JADRUbO0kMDRURIFtKQhUbYE5RAhUbaVpDQUpE";
const _scDecoded = JSON.parse(_d(_sc, 999));
export const SCRABBLE_SCORES = _scDecoded;

// Chunk metadata
const _chunks = {
    c0: { start: 0, end: 49, seed: 1 },
    c1: { start: 50, end: 99, seed: 2 },
    c2: { start: 100, end: 149, seed: 3 },
    c3: { start: 150, end: 199, seed: 4 },
    c4: { start: 200, end: 249, seed: 5 },
    c5: { start: 250, end: 268, seed: 6 }
};

// Decoded chunks cache
const _cache = {};

// Chunk data lookup object
const _chunkData = {
    c0: "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",
    c1: "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",
    c2: "C1gCXFsQCwNbBxVBCBgQCyNbNyhyPzgQHVoqPyhhNUlvHVoKHxZGGAJdX1pDK1h0PiphYlpVUil8PjlrEyVVUhlSGA5VXgoQFQkRVjAQXxcMHlgfTgpWWx0aBBNFCUlvTFRbQUoCTlFJEw8WAh5ATlFpEzo2KFgfTipwcDY9PzQRMUcQQhcVBQ5aAwUQCyNbMjVrTkcQcDo4Pj58IklvHVoaEQ5WCwRAWB0KUkBoTgVdRBZbXFhFCRlQEyUEXFgCXFkQCwNbBxVBCBgQCyNbNDVkIkkeEzc7Oj9wOElvHVoKHxZGGAJdX1pDK1h3Izx8E1RbPzh5KShmEyVVUhlSGA5VXgoQFQkRVjAQUBwPFQhRTkcQXxcMHlhuEUcQAEhKUkBIThxdQxwKUkBoTi13dFpVUjtlKTlzdj1bLVYRHwReRAwQHxQRVjAQdz08UlYRLT13Yzk+NVhuQElRUAwcFxVBBQ5BE0IiUhRcGQUQHVoYFBBWDx9bRx1bLQcfTloCBVpDC1hEAxlWQlpDK1hgODJ+dFpVUjBmKCx3EyVVUglcAB5GWBcXUkBoTjhmaDQ8UlYRJj52dj1bLVYRDwpGVB8WAhNWH0kIaloXHw9dTkcQXxcMHlhuEUcQAEhMUkBIThxdQxwKUkBoTiplcCFbXFhyLz9ncDRbLVYRHwReRAwQHxQRVjAQcC84KVgfTipxZS04PFhuQElRUAwcFxVBBQ5BE0IiUhtXGg5AU1pVUhtXBg5RRREPFVhuEUcQAEhPUkBIThxdQxwKUkBoTi13fzs8UlYRLypmcjBbLVYRHwReRAwQHxQRVjAQdz03Mz8RQElxcCw6OFhuQElRUAwcFxVBBQ5BE0IiUhRcGQUQHVoPFQhRTjZPHVpIQE0RVhAQRhcLFAkRVjAQczk1PFgfTih6ZCo6OFhuQElBXhQMBBNcAkkIalo7MTZ/TkcQcjAsIjl7TjYeExsYBB9UAxlbVAtbSiERAgRHX1pVUhRcGQUQbAVVUksDVEkISloOHwhXH0kIalo/JTR3TkcQcDY3JTt/TjYeEwsWHA9HBQRcE0IiUjxmIi8QHVo4PjRmLScQbFRbExtHCQxdQxEcA1gJN0lcXg0XUlYRDQ9YVBsNGQxWTjZPHVpIQEMRVhAQRhcLFAkRVjAQYjAgUlYRLip+cDY6NVhuQElBXhQMBBNcAkkIaloqOCMRQElwcDQ4Pjl2TjYeExsYBB9UAxlbVAtbSiERDQ9YVBsNGQxWTkcQXxcMHlhuEUcQAElJUkBIThxdQxwKUkBoTjpndD03UlYRPC58fyFbLVYRHwReRAwQHxQRVjAQYC08NTQRQElidDY3KVhuQElRUAwcFxVBBQ5BE0IiUhRcGQUQHVoXHw9dTjZPHVpIQUsRVhAQRhcLFAkRVjAQcio4KiMRQEl0cC01JFhuQElBXhQMBBNcAkkIalo6IjtpNUkeEz44JTZnTjYeExsYBB9UAxlbVAtbSiERDQ9YVBsNGQxWTkcQXxcMHlhuEUcQAElLUkBIThxdQxwKUkBoTiF9aFpVUjt9Kzl7fSFbLVYRHwReRAwQHxQRVjAQezcgUlYRLSV1YzE1KVhuQElRUAwcFxVBBQ5BE0IiUhRcGQUQHVoYFAxWHgkQbAVVUksCX0kISloOHwhXH0kIalopPDt9TkcQeTkpID99TjYeEwsWHA9HBQRcE0IiUip/LSUQHVoxMSpjKSUQbFRbExtHCQxdQxEcA1gJN0lcXg0XUlYRGg5AU1okDVYRXVoGE0ICUg1cHg9BE0IiUjlqLyd3E1RbNi99IjIQbFRbAxVfGR9bXhZbSiERLzJxfT1bXFh1OSV8aFokXFhQDR9XVhcLGR9ATlFpExYWBRQRQElTVRIcEw5aGg4QbAVVUksCWUkISloOHwhXH0kIaloyOT4RQElzYyowJjt/TjYeEwsWHA9HBQRcE0IiUjF6KEkeEzkrIjNlLScQbFRbExtHCQxdQxEcA1gJN0lcXg0XUlYRAgRHX1okDVYRXVoEE0ICUg1cHg9BE0IiUi5yICcQHVo+PDVxLScQbFRbAxVfGR9bXhZbSiEROCp+fVpVUj1/IylzfVokXFhQDR9XVhcLGR9ATlFpExkdGh9QGAJEVFpVUhtXBg5RRREPFVhuEUcQAElOUkBIThxdQxwKUkBoTiF9ej1bXFh6Ij17ZT1bLVYRHwReRAwQHxQRVjAQezcyNVgfTiJ8ZzEtNVhuQElRUAwcFxVBBQ5BE0IiUhRcGQUQHVoPFQhRTjZPHVpIQUIRVhAQRhcLFAkRVjAQdjEvNVgfTjh3ZSw1NVhuQElBXhQMBBNcAkkIalo+OSx2TkcQYj0tJDZ2TjYeExsYBB9UAxlbVAtbSiERGg5AU1pVUgxWHgkQbAVVUksCVUkISloOHwhXH0kIaloxNTZjTkcQZTA2JT17TjYeEwsWHA9HBQRcE0IiUjJ2IDsQHVotODVmKyMQbFRbExtHCQxdQxEcA1gJN0lEVAobUlYRDwRcWw0XEw5aAwUQbAVVUksBXEkISloOHwhXH0kIaloxPy9hTkcQeTc3Py9hTjYeEwsWHA9HBQRcE0IiUjJ8OTkQHVoxPzR8OTkQbFRbExtHCQxdQxEcA1gJN0lcXg0XUlYRAgRHX1okDVYRXVkDE0ICUg1cHg9BE0IiUi17IyYQHVoqODt3IzwQbFRbAxVfGR9bXhZbSiEROyN9fFpVUil7LS99ZlokXFhQDR9XVhcLGR9ATlFpEwgLHxRcGQUQHVoXHw9dTjZPHVpIQkgRVhAQRhcLFAkRVjAQci0rJj8RQElwYzE3N1huQElBXhQMBBNcAkkIalo6JShlKUkeEzorOTR0TjYeExsYBB9UAxlbVAtbSiERAgRHX1pVUgxWHgkQbAVVUksBX0kISloOHwhXH0kIalowPTt0KUkeEywuOTl2TjYeEwsWHA9HBQRcE0IiUjN+LSx3E1RbJC16Ly4QbFRbExtHCQxdQxEcA1gJN0lcXg0XUlYRDQ9EVAobUidOQEkDA0xbSgERGwRAVQtbSiERJC5+fVpVUix6Lz97fFokXFhAAwdHRREWHlgJN0l6dDQ1UlYROiJxZTE0UicfTghTRR0eHwhaCRgQCyNbHhVGAkkeExYWBRQRMRYeE0lLRVgJF0lFXgodA1gJN0l0fjc9UlYRKi5/cDQ8UicfThhdXQ0NGRVdTlFpEz42Pz4RQEl0dDU4PD8RMUcQUhkNFR1cHgJXQlpDK1hdAx5cE1RbER5ZCQhGWA4cUidOQEkDA05bSgERGwRAVQtbSiERLidzcjNbXFh7LTtiaFokXFhAAwdHRREWHlgJN0lwfTk6O1gfTiNzYSggUicfTghTRR0eHwhaCRgQCyNbER5ZCQhGWA4cUlYRDQ9YVBsNGQxWTjZPHVpIQk0RVhAQRhcLFAkRVjAQdCorPygRQElmeTErNFhuQElBXhQMBBNcAkkIalo8Iih8PkkeEywxOSh3TjYeExsYBB9UAxlbVAtbSiERAgRHX1pVUhRGAQlXQ1okDVYRXVkKE0ICUg1cHg9BE0IiUjZmIih6E1RbNChyKj8QbFRbAxVfGR9bXhZbSiERID58cjBbXFh3Pip0ZVokXFhQDR9XVhcLGR9ATlFpExYWBRQRQElcXg0XUidOQEkDA0FbSgERGwRAVQtbSiERISJ1eSxbXFhxICJ8dVokXFhAAwdHRREWHlgJN0l/eD8xJFgfTil+eDY9UicfTghTRR0eHwhaCRgQCyNbBh9BDkkeExkdGh9QGAJEVFokDVYRXVgCE0ICUg1cHg9BE0IiUip6OCh6E1RbMT5yPD8QbFRbAxVfGR9bXhZbSiERPCJmcjBbXFhyKCpiZVokXFhQDR9XVhcLGR9ATlFpExYWBRQRQElEVAobUidOQEkDAklbSgERGwRAVQtbSiERKyp8dlpVUjl8OSVmaFokXFhAAwdHRREWHlgJN0l1cDY+UlYRLyRnfywgUicfTghTRR0eHwhaCRgQCyNbHhVGAkkeExYWBRQRMRYeE0lKQlgJF0lFXgodA1gJN0llfi9bXFhxLT9mdCogUicfThhdXQ0NGRVdTlFpEy82J1gfTilzZSw8IiMRMUcQUhkNFR1cHgJXQlpDK1hdAx5cE1RbHhVGAklvTFRbQUkATlFJEw8WAh5ATlFpEygwPjERQElwdDs2PT8RMUcQQhcVBQ5aAwUQCyNbIDN9J0keEzo8MzV+KUlvHVoaEQ5WCwRAWB0KUkBoTgpWWx0aBBNFCUkeEw4cAhgRMRYeE0lKRFgJF0lFXgodA1gJN0l4ZDE6NVgfTiR0ZT03UicfThhdXQ0NGRVdTlFpEzIsOTl2TkcQfj4tNTQRMUcQUhkNFR1cHgJXQlpDK1hdAx5cE1RbER5FCRlQEyUEXFgCX14QCwNbBxVBCBgQCyNbMz9/IEkeEy88MTZnJElvHVoKHxZGGAJdX1pDK1hwKSd+E1RbJz9yID96EyVVUhlSGA5VXgoQFQkRVjAQXxcMHlgfTgVdRBZbLQcfTloBB1pDC1hEAxlWQlpDK1hxLSd+E1RbMj97JSV2EyVVUglcAB5GWBcXUkBoTilzfTRbXFhxKSN7fzxbLVYRDwpGVB8WAhNWH0kIaloXHw9dTkcQEyUEXFgCX1wQCwNbBxVBCBgQCyNbNjtwOEkeEzosJC58IklvHVoKHxZGGAJdX1pDK1h1LShmE1RbMi9nOCR8EyVVUhlSGA5VXgoQFQkRVjAQXxcMHlgfTgVdRBZbLQcfTloBCVpDC1hEAxlWQlpDK1hkJCJ+dFpVUi57JSh5EyVVUglcAB5GWBcXUkBoTjx6eDQ8UlYROCN7cjNbLVYRDwpGVB8WAhNWH0kIaloaHxRZGQVRRREWHlgfTgpWWx0aBBNFCUlvTFRbQUkKTlFJEw8WAh5ATlFpEzU2Jj8RQEl0cC42JSgRMUcQQhcVBQ5aAwUQCyNbPTVlKUkeEz44JjVmPklvHVoaEQ5WCwRAWB0KUkBoTgVdRBZbXFhdAx5cEyUEXFgCWFsQCwNbBxVBCBgQCyNbICh2PzgQHVo9Ij9gP0lvHVoKHxZGGAJdX1pDK1hjPi5hYlpVUj5hKThhEyVVUhlSGA5VXgoQFQkRVjAQXxcMHlgfTgVdRBZbLQcfTloGAFpDC1hEAxlWQlpDK1hwPi5lE1RbMi93Ky5mEyVVUglcAB5GWBcXUkBoTihgdC9bXFhxOS91dCxbLVYRDwpGVB8WAhNWH0kIaloXHw9dTkcQXxcMHlhuEUcQAExLUkBIThxdQxwKUkBoTiRgdT0rUlYRKiRgcj1bLVYRHwReRAwQHxQRVjAQfio9NSgRQEl0fio6NVhuQElRUAwcFxVBBQ5BE0IiUhRcGQUQHVoXHw9dTjZPHVpIREkRVhAQRhcLFAkRVjAQfjs6JSgRQEl2Yy03O1huQElBXhQMBBNcAkkIalo2MzlmPkkeEzwrJTR4TjYeExsYBB9UAxlbVAtbSiERGg5AU1pVUhtXBg5RRREPFVhuEUcQAExNUkBIThxdQxwKUkBoTjx3dDNbXFhnOy58ZSFbLVYRHwReRAwQHxQRVjAQZj08O1gfTj9ldDYtKVhuQElRUAwcFxVBBQ5BE0IiUhRcGQUQHVoXBRdRCRkQbAVVUksHWUkISloOHwhXH0kIaloxMTZ1TkcQdCAtNTRnTjYeEwsWHA9HBQRcE0IiUjJyIC0QHVo8KC52Ij8QbFRbExtHCQxdQxEcA1gJN0lcXg0XUlYRAgRHX1okDVYRXV8EE0ICUg1cHg9BE0IiUi5hJSh5E1RbPDN0JD8QbFRbAxVfGR9bXhZbSiERODl7cjNbXFh/JSx6ZVokXFhQDR9XVhcLGR9ATlFpExYWBRQRQElcXg0XUidOQEkDBU9bSgERGwRAVQtbSiERJCp+fVpVUj1hIzxmeVokXFhAAwdHRREWHlgJN0l6cDQ1UlYRKzl9ZiwxUicfTghTRR0eHwhaCRgQCyNbHhVGAkkeExYWBRQRMRYeE0lNSFgJF0lFXgodA1gJN0l/dDQtUlYRLSZzaz09UicfThhdXQ0NGRVdTlFpEzU8PC4RQElzfDkjNT4RMUcQUhkNFR1cHgJXQlpDK1hFCRlQE1RbBh9BDklvTFRbQU4KTlFJEw8WAh5ATlFpEzo4Pj4RQEl8fjo2NCMRMUcQQhcVBQ5aAwUQCyNbMjt9KEkeEzY2MjV3NUlvHVoaEQ5WCwRAWB0KUkBoTgVdRBZbXFhdAx5cEyUEDQ==",
    c3: "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",
    c4: "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",
    c5: "C1gEWVsWCANbBxVECBgWCCNbIzV1J0kYEC4wIzN5IklpHloKHxZDGAJbXFpDK1hlIyh/EFRbJjNlJSR6ECVVUhlXGA5TXQoQFQkUVjAWXBcMHlgaTgVbRxZbLQcaTlkBA1pDC1hBAxlQQVpDK1hyOT9tEFRbMj93OT9tECVVUglZAB5AWxcXUkBtTi9hZiFbXFh0KSphZiFbLVYUDwpAVx8WAhNTH0kOaVoXHw9YTkcWXBcMHlhrEUcWAE1LUkBNThxbQBwKUkBtTihmdy9bXFh1JC5xYT1bLVYUHwRYRwwQHxQUVjAWcSo8J1gaTih8dz0qNVhrQElXUwwcFxVEBQ5HEEIiUhRZGQUWHloXHw9YTjZJHlpLRUkUVhAWRRcLFAkUVjAWdDE1PVgaTiN1YDw1KVhrQElHXRQMBBNZAkkOaVo/OTZ7TkcWejkrNDZvTjYYEBsYBB9RAxldVwtbSiEUAgRBXFpVUhtSGg5GUFokDVYUXl4AEEICUg1ZHg9HEEIiUjJjKy4WHlouNTNxJD8Wb1RbAxVaGR9dXRZbSiEUJD5zd1pVUi1zJSx8ZlokXFhVDR9RVRcLGR9FTlFvEBkdGh9VGAJCV1pVUhRZGQUWbwVVUkgDWUkOSVoOHwhSH0kOaVo7MTl9TkcWYTkvOTRxTjYYEAsWHA9CBQRaEEIiUjh3LyAWHloqMSx/IiwWb1RbExtCCQxbQBEcA1gMN0lVVg4cAhgUQElCVwobUidLQEkGB05bSgEUGwRGVgtbSiEULiR6dlpVUjhkLSV3elokXFhFAwdBRhEWHlgMN0l2fTY9UlYULjl1fDsxUicaTghVRh0eHwhfCRgWCCNbHhVDAkkYEBYWBRQUMRYYEEpMR1gMF0lDXQodA1gMN0lgdzQ1UlYUKTNkdyotUicaThhbXg0NGRVYTlFvECw8PDYUQElxaig8Ii4UMUcWURkNFR1ZHgJRQVpDK1hACRlWEFRbHhVDAklpT1RbQk8OTlFPEA8WAh5FTlFvEDo8Pj4UQEl1cTs8IC4UMUcWQRcVBQ5fAwUWCCNbMj94KEkYEDk6Mz9mOElpHloaEQ5TCwRGWx0KUkBtTh1RQBpbXFhACRlWECUEXFgEWVIWCANbBxVECBgWCCNbNzNkIEkYEDs2PTd5IklpHloKHxZDGAJbXFpDK1hxJTl4EFRbMzV7ISR6ECVVUhlXGA5TXQoQFQkUVjAWXBcMHlgaTgpQWB0aBBNACUlpT1RbQkwGTlFPEA8WAh5FTlFvEC8wPDYUQElyez8sIj8UMUcWQRcVBQ5fAwUWCCNbJzN6IEkYED4wNy9kKUlpHloaEQ5TCwRGWx0KUkBtTh1RQBpbXFhYAx5aECUEXFgEWloWCANbBxVECBgWCCNbNDNlJEkYECstJSp/KElpHloKHxZDGAJbXFpDK1hyJTh8EFRbIy5jPCJwECVVUhlXGA5TXQoQFQkUVjAWXBcMHlgaTgpQWB0aBBNACUlpT1RbQkwETlFPEA8WAh5FTlFvEDAwPDYUQEl8ZzU2JSgUMUcWQRcVBQ5fAwUWCCNbODN6IEkYEDAsPTVjPklpHloaEQ5TCwRGWx0KUkBtTgVbRxZbXFhYAx5aECUEXFgEWlgWCANbBxVECBgWCCNbODV6NUkYEDw2PDZ3PklpHloKHxZDGAJbXFpDK1h+IydtEFRbNDV6ICpmECVVUhlXGA5TXQoQFQkUVjAWUxwTFRlCBR1REFRbHhVDAklpT1RbQkwCTlFPEA8WAh5FTlFvEC84OS4UQElgfTU4JDUUMUcWQRcVBQ5fAwUWCCNbJzt/OEkYECw2PTtiI0lpHloaEQ5TCwRGWx0KUkBtTh1RQBpbXFhYAx5aECUEXFgEWl4WCANbBxVECBgWCCNbJzN4KEkYEDU2PjFzNUlpHloKHxZDGAJbXFpDK1hhJSVwEFRbPTV4Jy5tECVVUhlXGA5TXQoQFQkUVjAWXBcMHlgaTgVbRxZbLQcaTlkCBFpDC1hBAxlQQVpDK1hiPiJkEFRbJDJ/Pj9tECVVUglZAB5AWxcXUkBtTj9meyhbXFhiJCJmZiFbLVYUDwpAVx8WAhNTH0kOaVoXHw9YTkcWXA0UEh9ETjZJHlpLRk0UVhAWRRcLFAkUVjAWZTk1PFgaTip4ZTkgI1hrQElHXRQMBBNZAkkOaVouMTZ6TkcWczQuMSNlTjYYEBsYBB9RAxldVwtbSiEUAgRBXFpVUhtSGg5GUFokDVYUXl0MEEICUg1ZHg9HEEIiUiN5OUkYEDowPzZ5KzIWb1RbAxVaGR9dXRZbSiEUNSRhEFRbMjN5ICRza1okXFhVDR9RVRcLGR9FTlFvEAgLHxRZGQUWHloXHw9YTjZJTw=="
};

// Get chunk for a puzzle number
function _getChunk(puzzleNum) {
    const chunkIdx = Math.floor(puzzleNum / 50);
    const chunkKey = `c${chunkIdx}`;
    const chunkInfo = _chunks[chunkKey];
    
    if (!chunkInfo) return null;
    
    // Check cache first
    if (_cache[chunkKey]) {
        return _cache[chunkKey];
    }
    
    // Decode chunk
    const encoded = _chunkData[chunkKey];
    if (!encoded) return null;
    const decoded = JSON.parse(_d(encoded, chunkInfo.seed));
    _cache[chunkKey] = decoded;
    
    return decoded;
}

// Proxy object for PUZZLE_DATA that lazily decodes chunks
const _puzzleDataProxy = new Proxy({}, {
    get(target, prop) {
        const puzzleNum = Number(prop);
        if (isNaN(puzzleNum)) {
            // Handle special properties like 'length', Symbol.iterator, etc.
            return target[prop];
        }
        
        const chunk = _getChunk(puzzleNum);
        return chunk ? chunk[puzzleNum] : undefined;
    },
    has(target, prop) {
        const puzzleNum = Number(prop);
        if (isNaN(puzzleNum)) return prop in target;
        const chunk = _getChunk(puzzleNum);
        return chunk && puzzleNum in chunk;
    },
    ownKeys(target) {
        // Return all puzzle numbers (0 to maxPuzzle)
        return Array.from({ length: 269 }, (_, i) => String(i));
    },
    getOwnPropertyDescriptor(target, prop) {
        const puzzleNum = Number(prop);
        if (isNaN(puzzleNum)) return undefined;
        const value = _puzzleDataProxy[puzzleNum];
        return value ? { enumerable: true, configurable: true, value } : undefined;
    }
});

export const PUZZLE_DATA = _puzzleDataProxy;

// Get all letters from a puzzle (combined anagram)
export function getPuzzleLetters(day) {
    const puzzle = PUZZLE_DATA[day];
    if (!puzzle) return [];
    
    const combined = puzzle.words.join('');
    // Shuffle the letters for the puzzle deterministically so all players see
    // the same "random" jumble for a given puzzle.
    const seed = hashStringToUint32(`day:${day}|${combined}`);
    return seededShuffleArray(combined.split(''), seed);
}

// Deterministic shuffle helpers
// - hashStringToUint32: stable string -> 32-bit seed
// - mulberry32: simple deterministic PRNG
// - seededShuffleArray: Fisherâ€“Yates using seeded PRNG (returns a new array)

function hashStringToUint32(input) {
    // FNV-1a 32-bit hash
    let hash = 0x811c9dc5;
    for (let i = 0; i < input.length; i++) {
        hash ^= input.charCodeAt(i);
        // hash *= 16777619 (mod 2^32) using shifts for speed/portability
        hash = (hash + (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24)) >>> 0;
    }
    return hash >>> 0;
}

function mulberry32(seed) {
    let t = seed >>> 0;
    return function next() {
        t += 0x6D2B79F5;
        let x = t;
        x = Math.imul(x ^ (x >>> 15), x | 1);
        x ^= x + Math.imul(x ^ (x >>> 7), x | 61);
        return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
    };
}

function seededShuffleArray(array, seed) {
    const shuffled = [...array];
    const rand = mulberry32(seed);
    for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(rand() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
}

// Calculate word score
export function calculateWordScore(word) {
    return word.split('').reduce((score, letter) => {
        return score + (SCRABBLE_SCORES[letter.toUpperCase()] || 0);
    }, 0);
}

// Validate solution
// Words must be in the correct positions (word1 in slot 0, word2 in slot 1)
export function validateSolution(day, word1, word2) {
    const puzzle = PUZZLE_DATA[day];
    if (!puzzle) return false;
    
    const solution = puzzle.solution;
    // Words must be in the correct order - word1 must match solution[0] and word2 must match solution[1]
    return word1 === solution[0] && word2 === solution[1];
}

// Date and Puzzle Mapping System
// Start date: December 1, 2025 (puzzle #1)
export const PUZZLE_START_DATE = new Date(2025, 11, 1); // Month is 0-indexed, so 11 = December

// Get puzzle number for a given date
export function getPuzzleNumberForDate(date) {
    if (!(date instanceof Date)) {
        date = new Date(date);
    }
    
    // Set time to start of day for accurate comparison
    const puzzleDate = new Date(date);
    puzzleDate.setHours(0, 0, 0, 0);
    const startDate = new Date(PUZZLE_START_DATE);
    startDate.setHours(0, 0, 0, 0);
    
    // Calculate days difference
    const timeDiff = puzzleDate.getTime() - startDate.getTime();
    const daysDiff = Math.floor(timeDiff / (1000 * 60 * 60 * 24));
    
    // Puzzle number is 1-indexed, so add 1
    return daysDiff + 1;
}

// Get date for a given puzzle number
export function getDateForPuzzleNumber(puzzleNum) {
    const puzzleNumber = parseInt(puzzleNum);
    if (isNaN(puzzleNumber) || puzzleNumber < 0) {
        return null;
    }
    
    // Puzzle #0 is a dummy/test puzzle, return a placeholder date (Dec 1, 2025)
    if (puzzleNumber === 0) {
        return new Date(PUZZLE_START_DATE);
    }
    
    const date = new Date(PUZZLE_START_DATE);
    date.setDate(date.getDate() + (puzzleNumber - 1));
    return date;
}

// Check if we're in advent mode (for test mode only) or daily mode (standard format)
// Standard format is always daily mode - advent mode only available via test parameter
export function isAdventMode() {
    // Check for test mode via URL parameter
    const urlParams = new URLSearchParams(window.location.search);
    const testValue = urlParams.get('test');
    
    // Advent test mode forces advent mode (for testing calendar view)
    if (testValue === 'advent') {
        return true;
    }
    
    // Standard format: always return false (daily mode)
    return false;
}

// Format date as YYYY-MM-DD string
export function formatDateString(date) {
    if (!(date instanceof Date)) {
        date = new Date(date);
    }
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
}

// Parse date string (YYYY-MM-DD) to Date object
export function parseDateString(dateString) {
    const parts = dateString.split('-');
    if (parts.length !== 3) return null;
    const year = parseInt(parts[0]);
    const month = parseInt(parts[1]) - 1; // Month is 0-indexed
    const day = parseInt(parts[2]);
    return new Date(year, month, day);
}


