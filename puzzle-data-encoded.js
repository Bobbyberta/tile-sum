// Encoded puzzle data - generated by build script
// Do not edit this file directly - edit puzzle-data.js and run: npm run build:data


function _d(s, k) {
    const k2 = `pz${k}lk${k * 7}xy`;
    let d = atob(s);
    const k3 = String(k2);
    return d.split('').map((c, i) => {
        const kc = k3.charCodeAt(i % k3.length);
        return String.fromCharCode(c.charCodeAt(0) ^ kc);
    }).join('');
}

// Encoded SCRABBLE_SCORES (small, so encode directly)
const _sc = "C1h4GwNdRxR7GwlLVVI5GwMKQElyGwMBVFs1WAMIFU4tFAMNH1o+UkALFRskSQwNFRExW0pLFRtzTlEOFRt4WkNFVht1G1ZaGht0EUJKXFh3GwNdRxR2GwlJVVIqGwMKQElnGwMCSFVSKBsDCEBJZRsDAlRbJFgDCBVOPhQDCB9aL1JADRUbO0kMDRURIFtKQhUbYE5RAhUbaVpDQUpE";
const _scDecoded = JSON.parse(_d(_sc, 999));
export const SCRABBLE_SCORES = _scDecoded;

// Chunk metadata
const _chunks = {
    c0: { start: 0, end: 49, seed: 1 },
    c1: { start: 50, end: 99, seed: 2 },
    c2: { start: 100, end: 149, seed: 3 },
    c3: { start: 150, end: 199, seed: 4 },
    c4: { start: 200, end: 249, seed: 5 },
    c5: { start: 250, end: 268, seed: 6 }
};

// Decoded chunks cache
const _cache = {};

// Chunk data lookup object
const _chunkData = {
    c0: "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",
    c1: "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",
    c2: "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",
    c3: "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",
    c4: "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",
    c5: "C1gEWVsWCANbBxVECBgWCCNbIzV1J0kYEC4wIzN5IklpHloKHxZDGAJbXFpDK1hlIyh/EFRbJjNlJSR6ECUEXFgEWVoWCANbBxVECBgWCCNbNC9iNUkYEDo8MS9iNUlpHloKHxZDGAJbXFpDK1hyOT9tEFRbMj93OT9tECUEXFgEWVkWCANbBxVECBgWCCNbMyhzO0kYEDsxNT9lKUlpHloKHxZDGAJbXFpDK1h1Pi5jEFRbMzJzKThxECUEXFgEWVgWCANbBxVECBgWCCNbNjN6IUkYEDA4Ij56NUlpHloKHxZDGAJbXFpDK1hwJSd5EFRbODtkKCdtECUEXFgEWV8WCANbBxVECBgWCCNbOC9xKUkYEC88OT1+OElpHloKHxZDGAJbXFpDK1h+OSxxEFRbJz9/KyNgECUEXFgEWV4WCANbBxVECBgWCCNbMjt1J0kYECs4JjN4K0lpHloKHxZDGAJbXFpDK1h0LSh/EFRbIztgJSVzECUEXFgEWV0WCANbBxVECBgWCCNbMjV4KEkYEDorMTR1JElpHloKHxZDGAJbXFpDK1h0IyVwEFRbMih3Iih8ECUEXFgEWVwWCANbBxVECBgWCCNbJD96IEkYED0hID9kOElpHloKHxZDGAJbXFpDK1hiKSd4EFRbNSJmKTlgECUEXFgEWVMWCANbBxVECBgWCCNbMj94KEkYEDk6Mz9mOElpHloKHxZDGAJbXFpDK1h0KSVwEFRbMTl1KTtgECUEXFgEWVIWCANbBxVECBgWCCNbNzNkIEkYEDs2PTd5IklpHloKHxZDGAJbXFpDK1hxJTl4EFRbMzV7ISR6ECUEXFgEWlsWCANbBxVECBgWCCNbJzN6IEkYED4wNy9kKUlpHloKHxZDGAJbXFpDK1hhJSd4EFRbNjNxOTlxECUEXFgEWloWCANbBxVECBgWCCNbNDNlJEkYECstJSp/KElpHloKHxZDGAJbXFpDK1hyJTh8EFRbIy5jPCJwECUEXFgEWlkWCANbBxVECBgWCCNbODN6IEkYEDAsPTVjPklpHloKHxZDGAJbXFpDK1h+JSd4EFRbOC97Iz5mECUEXFgEWlgWCANbBxVECBgWCCNbODV6NUkYEDw2PDZ3PklpHloKHxZDGAJbXFpDK1h+IydtEFRbNDV6ICpmECUEXFgEWl8WCANbBxVECBgWCCNbJzt/OEkYECw2PTtiI0lpHloKHxZDGAJbXFpDK1hhLSJgEFRbJDV7LT97ECUEXFgEWl4WCANbBxVECBgWCCNbJzN4KEkYEDU2PjFzNUlpHloKHxZDGAJbXFpDK1hhJSVwEFRbPTV4Jy5tECUEXFgEWl0WCANbBxVECBgWCCNbJCh/PEkYECwxOShiNUlpHloKHxZDGAJbXFpDK1hiPiJkEFRbJDJ/Pj9tECUEXFgEWlwWCANbBxVECBgWCCNbJzt6IEkYEDk1JztvP0lpHloKHxZDGAJbXFpDK1hhLSd4EFRbMTZhLTJnECUEXFgEWlMWCANbBxVECBgWCCNbKTVjTkcWcDE2PDVxNUlpHloKHxZDGAJbXFpDK1hvIz4WHlo7OTV6IyxtECUEDQ=="
};

// Get chunk for a puzzle number
function _getChunk(puzzleNum) {
    const chunkIdx = Math.floor(puzzleNum / 50);
    const chunkKey = `c${chunkIdx}`;
    const chunkInfo = _chunks[chunkKey];
    
    if (!chunkInfo) return null;
    
    // Check cache first
    if (_cache[chunkKey]) {
        return _cache[chunkKey];
    }
    
    // Decode chunk
    const encoded = _chunkData[chunkKey];
    if (!encoded) return null;
    const decoded = JSON.parse(_d(encoded, chunkInfo.seed));
    _cache[chunkKey] = decoded;
    
    return decoded;
}

// Proxy object for PUZZLE_DATA that lazily decodes chunks
const _puzzleDataProxy = new Proxy({}, {
    get(target, prop) {
        const puzzleNum = Number(prop);
        if (isNaN(puzzleNum)) {
            // Handle special properties like 'length', Symbol.iterator, etc.
            return target[prop];
        }
        
        const chunk = _getChunk(puzzleNum);
        return chunk ? chunk[puzzleNum] : undefined;
    },
    has(target, prop) {
        const puzzleNum = Number(prop);
        if (isNaN(puzzleNum)) return prop in target;
        const chunk = _getChunk(puzzleNum);
        return chunk && puzzleNum in chunk;
    },
    ownKeys(target) {
        // Return all puzzle numbers (0 to maxPuzzle)
        return Array.from({ length: 269 }, (_, i) => String(i));
    },
    getOwnPropertyDescriptor(target, prop) {
        const puzzleNum = Number(prop);
        if (isNaN(puzzleNum)) return undefined;
        const value = _puzzleDataProxy[puzzleNum];
        return value ? { enumerable: true, configurable: true, value } : undefined;
    }
});

export const PUZZLE_DATA = _puzzleDataProxy;

// Get all letters from a puzzle (combined anagram)
export function getPuzzleLetters(day) {
    const puzzle = PUZZLE_DATA[day];
    if (!puzzle) return [];
    
    const combined = puzzle.words.join('');
    // Shuffle the letters for the puzzle
    return shuffleArray(combined.split(''));
}

// Shuffle array (Fisher-Yates algorithm)
function shuffleArray(array) {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
}

// Calculate word score
export function calculateWordScore(word) {
    return word.split('').reduce((score, letter) => {
        return score + (SCRABBLE_SCORES[letter.toUpperCase()] || 0);
    }, 0);
}

// Validate solution
// Words must be in the correct positions (word1 in slot 0, word2 in slot 1)
export function validateSolution(day, word1, word2) {
    const puzzle = PUZZLE_DATA[day];
    if (!puzzle) return false;
    
    const solution = puzzle.solution;
    // Words must be in the correct order - word1 must match solution[0] and word2 must match solution[1]
    return word1 === solution[0] && word2 === solution[1];
}

// Date and Puzzle Mapping System
// Start date: December 1, 2025 (puzzle #1)
export const PUZZLE_START_DATE = new Date(2025, 11, 1); // Month is 0-indexed, so 11 = December

// Get puzzle number for a given date
export function getPuzzleNumberForDate(date) {
    if (!(date instanceof Date)) {
        date = new Date(date);
    }
    
    // Set time to start of day for accurate comparison
    const puzzleDate = new Date(date);
    puzzleDate.setHours(0, 0, 0, 0);
    const startDate = new Date(PUZZLE_START_DATE);
    startDate.setHours(0, 0, 0, 0);
    
    // Calculate days difference
    const timeDiff = puzzleDate.getTime() - startDate.getTime();
    const daysDiff = Math.floor(timeDiff / (1000 * 60 * 60 * 24));
    
    // Puzzle number is 1-indexed, so add 1
    return daysDiff + 1;
}

// Get date for a given puzzle number
export function getDateForPuzzleNumber(puzzleNum) {
    const puzzleNumber = parseInt(puzzleNum);
    if (isNaN(puzzleNumber) || puzzleNumber < 0) {
        return null;
    }
    
    // Puzzle #0 is a dummy/test puzzle, return a placeholder date (Dec 1, 2025)
    if (puzzleNumber === 0) {
        return new Date(PUZZLE_START_DATE);
    }
    
    const date = new Date(PUZZLE_START_DATE);
    date.setDate(date.getDate() + (puzzleNumber - 1));
    return date;
}

// Check if we're in advent mode (for test mode only) or daily mode (standard format)
// Standard format is always daily mode - advent mode only available via test parameter
export function isAdventMode() {
    // Check for test mode via URL parameter
    const urlParams = new URLSearchParams(window.location.search);
    const testValue = urlParams.get('test');
    
    // Advent test mode forces advent mode (for testing calendar view)
    if (testValue === 'advent') {
        return true;
    }
    
    // Standard format: always return false (daily mode)
    return false;
}

// Format date as YYYY-MM-DD string
export function formatDateString(date) {
    if (!(date instanceof Date)) {
        date = new Date(date);
    }
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
}

// Parse date string (YYYY-MM-DD) to Date object
export function parseDateString(dateString) {
    const parts = dateString.split('-');
    if (parts.length !== 3) return null;
    const year = parseInt(parts[0]);
    const month = parseInt(parts[1]) - 1; // Month is 0-indexed
    const day = parseInt(parts[2]);
    return new Date(year, month, day);
}


