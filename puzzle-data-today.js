// Today's puzzle data - generated by build script
// Do not edit this file directly - edit puzzle-data.js and run: npm run build:data
// Contains puzzle #64 (chunk c1)


function _d(s, k) {
    const k2 = `pz${k}lk${k * 7}xy`;
    let d = atob(s);
    const k3 = String(k2);
    return d.split('').map((c, i) => {
        const kc = k3.charCodeAt(i % k3.length);
        return String.fromCharCode(c.charCodeAt(0) ^ kc);
    }).join('');
}

// Encoded SCRABBLE_SCORES (small, so encode directly)
const _sc = "C1h4GwNdRxR7GwlLVVI5GwMKQElyGwMBVFs1WAMIFU4tFAMNH1o+UkALFRskSQwNFRExW0pLFRtzTlEOFRt4WkNFVht1G1ZaGht0EUJKXFh3GwNdRxR2GwlJVVIqGwMKQElnGwMCSFVSKBsDCEBJZRsDAlRbJFgDCBVOPhQDCB9aL1JADRUbO0kMDRURIFtKQhUbYE5RAhUbaVpDQUpE";
const _scDecoded = JSON.parse(_d(_sc, 999));
export const SCRABBLE_SCORES = _scDecoded;

// Chunk metadata (today's chunk only)
const _chunks = {
    c1: { start: 50, end: 99, seed: 2 }
};

// Decoded chunks cache
const _cache = {};

// Chunk data lookup object (today's chunk only)
const _chunkData = {
    c1: "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"
};

// Get chunk for a puzzle number
function _getChunk(puzzleNum) {
    const chunkIdx = Math.floor(puzzleNum / 50);
    const chunkKey = `c${chunkIdx}`;
    const chunkInfo = _chunks[chunkKey];
    
    if (!chunkInfo) return null;
    
    // Check cache first
    if (_cache[chunkKey]) {
        return _cache[chunkKey];
    }
    
    // Decode chunk
    const encoded = _chunkData[chunkKey];
    if (!encoded) return null;
    const decoded = JSON.parse(_d(encoded, chunkInfo.seed));
    _cache[chunkKey] = decoded;
    
    return decoded;
}

// Proxy object for PUZZLE_DATA that lazily decodes chunks
// This will be extended by archive data loader
const _puzzleDataProxy = new Proxy({}, {
    get(target, prop) {
        const puzzleNum = Number(prop);
        if (isNaN(puzzleNum)) {
            // Handle special properties like 'length', Symbol.iterator, etc.
            return target[prop];
        }
        
        const chunk = _getChunk(puzzleNum);
        return chunk ? chunk[puzzleNum] : undefined;
    },
    has(target, prop) {
        const puzzleNum = Number(prop);
        if (isNaN(puzzleNum)) return prop in target;
        const chunk = _getChunk(puzzleNum);
        return chunk && puzzleNum in chunk;
    },
    ownKeys(target) {
        // Return all puzzle numbers (0 to maxPuzzle) - archive loader will extend this
        return Array.from({ length: 367 }, (_, i) => String(i));
    },
    getOwnPropertyDescriptor(target, prop) {
        const puzzleNum = Number(prop);
        if (isNaN(puzzleNum)) return undefined;
        const value = _puzzleDataProxy[puzzleNum];
        return value ? { enumerable: true, configurable: true, value } : undefined;
    }
});

export const PUZZLE_DATA = _puzzleDataProxy;

// Export internal functions for archive loader to extend the proxy
export const _extendPuzzleData = (archiveChunks, archiveChunkData) => {
    // Merge archive chunks into _chunks
    Object.assign(_chunks, archiveChunks);
    
    // Merge archive chunk data into _chunkData
    Object.assign(_chunkData, archiveChunkData);
};

// Get all letters from a puzzle (combined anagram)
export function getPuzzleLetters(day) {
    const puzzle = PUZZLE_DATA[day];
    if (!puzzle) return [];
    
    const combined = puzzle.words.join('');
    // Shuffle the letters for the puzzle deterministically so all players see
    // the same "random" jumble for a given puzzle.
    const seed = hashStringToUint32(`day:${day}|${combined}`);
    return seededShuffleArray(combined.split(''), seed);
}

// Deterministic shuffle helpers
// - hashStringToUint32: stable string -> 32-bit seed
// - mulberry32: simple deterministic PRNG
// - seededShuffleArray: Fisherâ€“Yates using seeded PRNG (returns a new array)

function hashStringToUint32(input) {
    // FNV-1a 32-bit hash
    let hash = 0x811c9dc5;
    for (let i = 0; i < input.length; i++) {
        hash ^= input.charCodeAt(i);
        // hash *= 16777619 (mod 2^32) using shifts for speed/portability
        hash = (hash + (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24)) >>> 0;
    }
    return hash >>> 0;
}

function mulberry32(seed) {
    let t = seed >>> 0;
    return function next() {
        t += 0x6D2B79F5;
        let x = t;
        x = Math.imul(x ^ (x >>> 15), x | 1);
        x ^= x + Math.imul(x ^ (x >>> 7), x | 61);
        return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
    };
}

function seededShuffleArray(array, seed) {
    const shuffled = [...array];
    const rand = mulberry32(seed);
    for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(rand() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
}

// Calculate word score
export function calculateWordScore(word) {
    return word.split('').reduce((score, letter) => {
        return score + (SCRABBLE_SCORES[letter.toUpperCase()] || 0);
    }, 0);
}

// Validate solution
// Words must be in the correct positions (word1 in slot 0, word2 in slot 1)
export function validateSolution(day, word1, word2) {
    const puzzle = PUZZLE_DATA[day];
    if (!puzzle) return false;
    
    const solution = puzzle.solution;
    // Words must be in the correct order - word1 must match solution[0] and word2 must match solution[1]
    return word1 === solution[0] && word2 === solution[1];
}

// Date and Puzzle Mapping System
// Start date: December 1, 2025 (puzzle #1)
export const PUZZLE_START_DATE = new Date(2025, 11, 1); // Month is 0-indexed, so 11 = December

// Get puzzle number for a given date
export function getPuzzleNumberForDate(date) {
    if (!(date instanceof Date)) {
        date = new Date(date);
    }
    
    // Set time to start of day for accurate comparison
    const puzzleDate = new Date(date);
    puzzleDate.setHours(0, 0, 0, 0);
    const startDate = new Date(PUZZLE_START_DATE);
    startDate.setHours(0, 0, 0, 0);
    
    // Calculate days difference
    const timeDiff = puzzleDate.getTime() - startDate.getTime();
    const daysDiff = Math.floor(timeDiff / (1000 * 60 * 60 * 24));
    
    // Puzzle number is 1-indexed, so add 1
    return daysDiff + 1;
}

// Get date for a given puzzle number
export function getDateForPuzzleNumber(puzzleNum) {
    const puzzleNumber = parseInt(puzzleNum);
    if (isNaN(puzzleNumber) || puzzleNumber < 0) {
        return null;
    }
    
    // Puzzle #0 is a dummy/test puzzle, return a placeholder date (Dec 1, 2025)
    if (puzzleNumber === 0) {
        return new Date(PUZZLE_START_DATE);
    }
    
    const date = new Date(PUZZLE_START_DATE);
    date.setDate(date.getDate() + (puzzleNumber - 1));
    return date;
}

// Check if we're in advent mode (for test mode only) or daily mode (standard format)
// Standard format is always daily mode - advent mode only available via test parameter
export function isAdventMode() {
    // Check for test mode via URL parameter
    const urlParams = new URLSearchParams(window.location.search);
    const testValue = urlParams.get('test');
    
    // Advent test mode forces advent mode (for testing calendar view)
    if (testValue === 'advent') {
        return true;
    }
    
    // Standard format: always return false (daily mode)
    return false;
}

// Format date as YYYY-MM-DD string
export function formatDateString(date) {
    if (!(date instanceof Date)) {
        date = new Date(date);
    }
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
}

// Parse date string (YYYY-MM-DD) to Date object
export function parseDateString(dateString) {
    const parts = dateString.split('-');
    if (parts.length !== 3) return null;
    const year = parseInt(parts[0]);
    const month = parseInt(parts[1]) - 1; // Month is 0-indexed
    const day = parseInt(parts[2]);
    return new Date(year, month, day);
}


