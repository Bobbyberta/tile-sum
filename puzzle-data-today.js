// Today's puzzle data - generated by build script
// Do not edit this file directly - edit puzzle-data.js and run: npm run build:data
// Contains puzzle #63 (chunk c1)


function _d(s, k) {
    const k2 = `pz${k}lk${k * 7}xy`;
    let d = atob(s);
    const k3 = String(k2);
    return d.split('').map((c, i) => {
        const kc = k3.charCodeAt(i % k3.length);
        return String.fromCharCode(c.charCodeAt(0) ^ kc);
    }).join('');
}

// Encoded SCRABBLE_SCORES (small, so encode directly)
const _sc = "C1h4GwNdRxR7GwlLVVI5GwMKQElyGwMBVFs1WAMIFU4tFAMNH1o+UkALFRskSQwNFRExW0pLFRtzTlEOFRt4WkNFVht1G1ZaGht0EUJKXFh3GwNdRxR2GwlJVVIqGwMKQElnGwMCSFVSKBsDCEBJZRsDAlRbJFgDCBVOPhQDCB9aL1JADRUbO0kMDRURIFtKQhUbYE5RAhUbaVpDQUpE";
const _scDecoded = JSON.parse(_d(_sc, 999));
export const SCRABBLE_SCORES = _scDecoded;

// Chunk metadata (today's chunk only)
const _chunks = {
    c1: { start: 50, end: 99, seed: 2 }
};

// Decoded chunks cache
const _cache = {};

// Chunk data lookup object (today's chunk only)
const _chunkData = {
    c1: "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"
};

// Get chunk for a puzzle number
function _getChunk(puzzleNum) {
    const chunkIdx = Math.floor(puzzleNum / 50);
    const chunkKey = `c${chunkIdx}`;
    const chunkInfo = _chunks[chunkKey];
    
    if (!chunkInfo) return null;
    
    // Check cache first
    if (_cache[chunkKey]) {
        return _cache[chunkKey];
    }
    
    // Decode chunk
    const encoded = _chunkData[chunkKey];
    if (!encoded) return null;
    const decoded = JSON.parse(_d(encoded, chunkInfo.seed));
    _cache[chunkKey] = decoded;
    
    return decoded;
}

// Proxy object for PUZZLE_DATA that lazily decodes chunks
// This will be extended by archive data loader
const _puzzleDataProxy = new Proxy({}, {
    get(target, prop) {
        const puzzleNum = Number(prop);
        if (isNaN(puzzleNum)) {
            // Handle special properties like 'length', Symbol.iterator, etc.
            return target[prop];
        }
        
        const chunk = _getChunk(puzzleNum);
        return chunk ? chunk[puzzleNum] : undefined;
    },
    has(target, prop) {
        const puzzleNum = Number(prop);
        if (isNaN(puzzleNum)) return prop in target;
        const chunk = _getChunk(puzzleNum);
        return chunk && puzzleNum in chunk;
    },
    ownKeys(target) {
        // Return all puzzle numbers (0 to maxPuzzle) - archive loader will extend this
        return Array.from({ length: 269 }, (_, i) => String(i));
    },
    getOwnPropertyDescriptor(target, prop) {
        const puzzleNum = Number(prop);
        if (isNaN(puzzleNum)) return undefined;
        const value = _puzzleDataProxy[puzzleNum];
        return value ? { enumerable: true, configurable: true, value } : undefined;
    }
});

export const PUZZLE_DATA = _puzzleDataProxy;

// Export internal functions for archive loader to extend the proxy
export const _extendPuzzleData = (archiveChunks, archiveChunkData) => {
    // Merge archive chunks into _chunks
    Object.assign(_chunks, archiveChunks);
    
    // Merge archive chunk data into _chunkData
    Object.assign(_chunkData, archiveChunkData);
};

// Get all letters from a puzzle (combined anagram)
export function getPuzzleLetters(day) {
    const puzzle = PUZZLE_DATA[day];
    if (!puzzle) return [];
    
    const combined = puzzle.words.join('');
    // Shuffle the letters for the puzzle deterministically so all players see
    // the same "random" jumble for a given puzzle.
    const seed = hashStringToUint32(`day:${day}|${combined}`);
    return seededShuffleArray(combined.split(''), seed);
}

// Deterministic shuffle helpers
// - hashStringToUint32: stable string -> 32-bit seed
// - mulberry32: simple deterministic PRNG
// - seededShuffleArray: Fisherâ€“Yates using seeded PRNG (returns a new array)

function hashStringToUint32(input) {
    // FNV-1a 32-bit hash
    let hash = 0x811c9dc5;
    for (let i = 0; i < input.length; i++) {
        hash ^= input.charCodeAt(i);
        // hash *= 16777619 (mod 2^32) using shifts for speed/portability
        hash = (hash + (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24)) >>> 0;
    }
    return hash >>> 0;
}

function mulberry32(seed) {
    let t = seed >>> 0;
    return function next() {
        t += 0x6D2B79F5;
        let x = t;
        x = Math.imul(x ^ (x >>> 15), x | 1);
        x ^= x + Math.imul(x ^ (x >>> 7), x | 61);
        return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
    };
}

function seededShuffleArray(array, seed) {
    const shuffled = [...array];
    const rand = mulberry32(seed);
    for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(rand() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
}

// Calculate word score
export function calculateWordScore(word) {
    return word.split('').reduce((score, letter) => {
        return score + (SCRABBLE_SCORES[letter.toUpperCase()] || 0);
    }, 0);
}

// Validate solution
// Words must be in the correct positions (word1 in slot 0, word2 in slot 1)
export function validateSolution(day, word1, word2) {
    const puzzle = PUZZLE_DATA[day];
    if (!puzzle) return false;
    
    const solution = puzzle.solution;
    // Words must be in the correct order - word1 must match solution[0] and word2 must match solution[1]
    return word1 === solution[0] && word2 === solution[1];
}

// Date and Puzzle Mapping System
// Start date: December 1, 2025 (puzzle #1)
export const PUZZLE_START_DATE = new Date(2025, 11, 1); // Month is 0-indexed, so 11 = December

// Get puzzle number for a given date
export function getPuzzleNumberForDate(date) {
    if (!(date instanceof Date)) {
        date = new Date(date);
    }
    
    // Set time to start of day for accurate comparison
    const puzzleDate = new Date(date);
    puzzleDate.setHours(0, 0, 0, 0);
    const startDate = new Date(PUZZLE_START_DATE);
    startDate.setHours(0, 0, 0, 0);
    
    // Calculate days difference
    const timeDiff = puzzleDate.getTime() - startDate.getTime();
    const daysDiff = Math.floor(timeDiff / (1000 * 60 * 60 * 24));
    
    // Puzzle number is 1-indexed, so add 1
    return daysDiff + 1;
}

// Get date for a given puzzle number
export function getDateForPuzzleNumber(puzzleNum) {
    const puzzleNumber = parseInt(puzzleNum);
    if (isNaN(puzzleNumber) || puzzleNumber < 0) {
        return null;
    }
    
    // Puzzle #0 is a dummy/test puzzle, return a placeholder date (Dec 1, 2025)
    if (puzzleNumber === 0) {
        return new Date(PUZZLE_START_DATE);
    }
    
    const date = new Date(PUZZLE_START_DATE);
    date.setDate(date.getDate() + (puzzleNumber - 1));
    return date;
}

// Check if we're in advent mode (for test mode only) or daily mode (standard format)
// Standard format is always daily mode - advent mode only available via test parameter
export function isAdventMode() {
    // Check for test mode via URL parameter
    const urlParams = new URLSearchParams(window.location.search);
    const testValue = urlParams.get('test');
    
    // Advent test mode forces advent mode (for testing calendar view)
    if (testValue === 'advent') {
        return true;
    }
    
    // Standard format: always return false (daily mode)
    return false;
}

// Format date as YYYY-MM-DD string
export function formatDateString(date) {
    if (!(date instanceof Date)) {
        date = new Date(date);
    }
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
}

// Parse date string (YYYY-MM-DD) to Date object
export function parseDateString(dateString) {
    const parts = dateString.split('-');
    if (parts.length !== 3) return null;
    const year = parseInt(parts[0]);
    const month = parseInt(parts[1]) - 1; // Month is 0-indexed
    const day = parseInt(parts[2]);
    return new Date(year, month, day);
}


